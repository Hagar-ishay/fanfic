"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remix-typedjson";
exports.ids = ["vendor-chunks/remix-typedjson"];
exports.modules = {

/***/ "(ssr)/./node_modules/remix-typedjson/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/remix-typedjson/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.serialize = exports.registerCustomType = exports.parse = exports.deserialize = exports.applyMeta = exports.useTypedRouteLoaderData = exports.useTypedLoaderData = exports.useTypedFetcher = exports.useTypedActionData = exports.typedjson = exports.typeddefer = exports.stringifyRemix = exports.redirect = exports.deserializeRemix = exports.TypedAwait = void 0;\nvar remix_1 = __webpack_require__(/*! ./remix */ \"(ssr)/./node_modules/remix-typedjson/dist/remix.js\");\nObject.defineProperty(exports, \"TypedAwait\", ({ enumerable: true, get: function () { return remix_1.TypedAwait; } }));\nObject.defineProperty(exports, \"deserializeRemix\", ({ enumerable: true, get: function () { return remix_1.deserializeRemix; } }));\nObject.defineProperty(exports, \"redirect\", ({ enumerable: true, get: function () { return remix_1.redirect; } }));\nObject.defineProperty(exports, \"stringifyRemix\", ({ enumerable: true, get: function () { return remix_1.stringifyRemix; } }));\nObject.defineProperty(exports, \"typeddefer\", ({ enumerable: true, get: function () { return remix_1.typeddefer; } }));\nObject.defineProperty(exports, \"typedjson\", ({ enumerable: true, get: function () { return remix_1.typedjson; } }));\nObject.defineProperty(exports, \"useTypedActionData\", ({ enumerable: true, get: function () { return remix_1.useTypedActionData; } }));\nObject.defineProperty(exports, \"useTypedFetcher\", ({ enumerable: true, get: function () { return remix_1.useTypedFetcher; } }));\nObject.defineProperty(exports, \"useTypedLoaderData\", ({ enumerable: true, get: function () { return remix_1.useTypedLoaderData; } }));\nObject.defineProperty(exports, \"useTypedRouteLoaderData\", ({ enumerable: true, get: function () { return remix_1.useTypedRouteLoaderData; } }));\nvar typedjson_1 = __webpack_require__(/*! ./typedjson */ \"(ssr)/./node_modules/remix-typedjson/dist/typedjson.js\");\nObject.defineProperty(exports, \"applyMeta\", ({ enumerable: true, get: function () { return typedjson_1.applyMeta; } }));\nObject.defineProperty(exports, \"deserialize\", ({ enumerable: true, get: function () { return typedjson_1.deserialize; } }));\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return typedjson_1.parse; } }));\nObject.defineProperty(exports, \"registerCustomType\", ({ enumerable: true, get: function () { return typedjson_1.registerCustomType; } }));\nObject.defineProperty(exports, \"serialize\", ({ enumerable: true, get: function () { return typedjson_1.serialize; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return typedjson_1.stringify; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtaXgtdHlwZWRqc29uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLCtCQUErQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLGdCQUFnQixHQUFHLHdCQUF3QixHQUFHLGtCQUFrQjtBQUN2WCxjQUFjLG1CQUFPLENBQUMsbUVBQVM7QUFDL0IsOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25ILG9EQUFtRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMvSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0csa0RBQWlELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzNILDhDQUE2QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNuSCw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDakgsc0RBQXFELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ25JLG1EQUFrRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM3SCxzREFBcUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbkksMkRBQTBELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzdJLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3ZDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCwrQ0FBOEMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDekgseUNBQXdDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzdHLHNEQUFxRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN2SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvaGFnYXIuaXNoYXkvZmFuZmljL25vZGVfbW9kdWxlcy9yZW1peC10eXBlZGpzb24vZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zZXJpYWxpemUgPSBleHBvcnRzLnJlZ2lzdGVyQ3VzdG9tVHlwZSA9IGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLmRlc2VyaWFsaXplID0gZXhwb3J0cy5hcHBseU1ldGEgPSBleHBvcnRzLnVzZVR5cGVkUm91dGVMb2FkZXJEYXRhID0gZXhwb3J0cy51c2VUeXBlZExvYWRlckRhdGEgPSBleHBvcnRzLnVzZVR5cGVkRmV0Y2hlciA9IGV4cG9ydHMudXNlVHlwZWRBY3Rpb25EYXRhID0gZXhwb3J0cy50eXBlZGpzb24gPSBleHBvcnRzLnR5cGVkZGVmZXIgPSBleHBvcnRzLnN0cmluZ2lmeVJlbWl4ID0gZXhwb3J0cy5yZWRpcmVjdCA9IGV4cG9ydHMuZGVzZXJpYWxpemVSZW1peCA9IGV4cG9ydHMuVHlwZWRBd2FpdCA9IHZvaWQgMDtcbnZhciByZW1peF8xID0gcmVxdWlyZShcIi4vcmVtaXhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlZEF3YWl0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLlR5cGVkQXdhaXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXNlcmlhbGl6ZVJlbWl4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLmRlc2VyaWFsaXplUmVtaXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWRpcmVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtaXhfMS5yZWRpcmVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVJlbWl4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLnN0cmluZ2lmeVJlbWl4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHlwZWRkZWZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtaXhfMS50eXBlZGRlZmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHlwZWRqc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLnR5cGVkanNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZVR5cGVkQWN0aW9uRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtaXhfMS51c2VUeXBlZEFjdGlvbkRhdGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VUeXBlZEZldGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbWl4XzEudXNlVHlwZWRGZXRjaGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlVHlwZWRMb2FkZXJEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLnVzZVR5cGVkTG9hZGVyRGF0YTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZVR5cGVkUm91dGVMb2FkZXJEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1peF8xLnVzZVR5cGVkUm91dGVMb2FkZXJEYXRhOyB9IH0pO1xudmFyIHR5cGVkanNvbl8xID0gcmVxdWlyZShcIi4vdHlwZWRqc29uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlNZXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZGpzb25fMS5hcHBseU1ldGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXNlcmlhbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRqc29uXzEuZGVzZXJpYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRqc29uXzEucGFyc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckN1c3RvbVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVkanNvbl8xLnJlZ2lzdGVyQ3VzdG9tVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRqc29uXzEuc2VyaWFsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZGpzb25fMS5zdHJpbmdpZnk7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remix-typedjson/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/remix-typedjson/dist/remix.js":
/*!****************************************************!*\
  !*** ./node_modules/remix-typedjson/dist/remix.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.redirect = exports.deserializeRemix = exports.stringifyRemix = exports.useTypedRouteLoaderData = exports.useTypedFetcher = exports.useTypedActionData = exports.useTypedLoaderData = exports.TypedAwait = exports.typeddefer = exports.typedjson = void 0;\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nconst react_1 = __webpack_require__(/*! @remix-run/react */ \"(ssr)/./node_modules/@remix-run/react/dist/esm/index.js\");\nconst server_runtime_1 = __webpack_require__(/*! @remix-run/server-runtime */ \"(ssr)/./node_modules/@remix-run/server-runtime/dist/esm/index.js\");\nconst _typedjson = __importStar(__webpack_require__(/*! ./typedjson */ \"(ssr)/./node_modules/remix-typedjson/dist/typedjson.js\"));\nconst typedjson = (data, init = {}) => {\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has('Content-Type')) {\n        headers.set('Content-Type', 'application/json; charset=utf-8');\n    }\n    return new Response(stringifyRemix(data), {\n        ...responseInit,\n        headers,\n    });\n};\nexports.typedjson = typedjson;\nconst typeddefer = (data, init = {}) => {\n    // wrap any Promises in the data with new Promises that will serialize the\n    // resolved data and add the meta to the response\n    Object.entries(data).forEach(([key, value]) => {\n        if (value instanceof Promise) {\n            ;\n            data[key] = value.then(resolvedData => {\n                const { meta } = _typedjson.serialize(resolvedData);\n                if (meta) {\n                    ;\n                    resolvedData['$$meta'] = meta;\n                }\n                return resolvedData;\n            });\n        }\n        else {\n            const { meta } = _typedjson.serialize(data);\n            if (meta) {\n                ;\n                data['$$meta'] = meta;\n            }\n        }\n    });\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    return (0, server_runtime_1.defer)(data, responseInit);\n};\nexports.typeddefer = typeddefer;\nfunction TypedAwait(props) {\n    if (!props.children)\n        return null;\n    return ((0, jsx_runtime_1.jsx)(react_1.Await, { ...props, children: data => {\n            if (data === null)\n                return null;\n            let deserializedData = deserializeRemix(data);\n            return props.children(deserializedData);\n        } }));\n}\nexports.TypedAwait = TypedAwait;\nfunction useTypedLoaderData() {\n    const data = (0, react_1.useLoaderData)();\n    return deserializeRemix(data);\n}\nexports.useTypedLoaderData = useTypedLoaderData;\nfunction useTypedActionData() {\n    const data = (0, react_1.useActionData)();\n    return deserializeRemix(data);\n}\nexports.useTypedActionData = useTypedActionData;\nfunction useTypedFetcher(opts) {\n    const fetcher = (0, react_1.useFetcher)(opts);\n    if (fetcher.data) {\n        const newData = deserializeRemix(fetcher.data);\n        fetcher.data = newData ?? undefined;\n    }\n    return fetcher;\n}\nexports.useTypedFetcher = useTypedFetcher;\nfunction useTypedRouteLoaderData(id) {\n    const match = (0, react_1.useMatches)().find(match => match.id === id);\n    if (!match)\n        return undefined;\n    return deserializeRemix(match.data);\n}\nexports.useTypedRouteLoaderData = useTypedRouteLoaderData;\nfunction stringifyRemix(data) {\n    // prevent double JSON stringification\n    let { json, meta } = _typedjson.serialize(data);\n    if (json && meta) {\n        if (json.startsWith('{')) {\n            json = `${json.substring(0, json.length - 1)},\\\"$$meta\\\":${JSON.stringify(meta)}}`;\n        }\n        else if (json.startsWith('[')) {\n            json = `{\"$$obj\":${json},\"$$meta\":${JSON.stringify(meta)}}`;\n        }\n    }\n    return json;\n}\nexports.stringifyRemix = stringifyRemix;\nfunction deserializeRemix(data) {\n    if (!data)\n        return data;\n    if (data.$$obj) {\n        // handle arrays wrapped in an object\n        return data.$$meta\n            ? _typedjson.applyMeta(data.$$obj, data.$$meta)\n            : data.$$obj;\n    }\n    else if (data.$$meta) {\n        // handle object with $$meta key\n        // remove before applying meta\n        const meta = data.$$meta;\n        delete data.$$meta;\n        return _typedjson.applyMeta(data, meta);\n    }\n    return data;\n}\nexports.deserializeRemix = deserializeRemix;\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/api/remix#redirect\n */\nconst redirect = (url, init = 302) => {\n    let responseInit = init;\n    if (typeof responseInit === 'number') {\n        responseInit = { status: responseInit };\n    }\n    else if (typeof responseInit.status === 'undefined') {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set('Location', url);\n    return new Response(null, {\n        ...responseInit,\n        headers,\n    });\n};\nexports.redirect = redirect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtaXgtdHlwZWRqc29uL2Rpc3QvcmVtaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLCtCQUErQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUN4UCxzQkFBc0IsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQWtCO0FBQzFDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUEyQjtBQUM1RCxnQ0FBZ0MsbUJBQU8sQ0FBQywyRUFBYTtBQUNyRCxrQ0FBa0M7QUFDbEMsb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0EsOEJBQThCO0FBQzlCLHNCQUFzQixtQ0FBbUMsY0FBYyxzQkFBc0I7QUFDN0Y7QUFDQTtBQUNBLHFCQUFxQixVQUFVLEtBQUssWUFBWSxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYWdhci5pc2hheS9mYW5maWMvbm9kZV9tb2R1bGVzL3JlbWl4LXR5cGVkanNvbi9kaXN0L3JlbWl4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZGlyZWN0ID0gZXhwb3J0cy5kZXNlcmlhbGl6ZVJlbWl4ID0gZXhwb3J0cy5zdHJpbmdpZnlSZW1peCA9IGV4cG9ydHMudXNlVHlwZWRSb3V0ZUxvYWRlckRhdGEgPSBleHBvcnRzLnVzZVR5cGVkRmV0Y2hlciA9IGV4cG9ydHMudXNlVHlwZWRBY3Rpb25EYXRhID0gZXhwb3J0cy51c2VUeXBlZExvYWRlckRhdGEgPSBleHBvcnRzLlR5cGVkQXdhaXQgPSBleHBvcnRzLnR5cGVkZGVmZXIgPSBleHBvcnRzLnR5cGVkanNvbiA9IHZvaWQgMDtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcIkByZW1peC1ydW4vcmVhY3RcIik7XG5jb25zdCBzZXJ2ZXJfcnVudGltZV8xID0gcmVxdWlyZShcIkByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWVcIik7XG5jb25zdCBfdHlwZWRqc29uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVkanNvblwiKSk7XG5jb25zdCB0eXBlZGpzb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gICAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSAnbnVtYmVyJyA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmluZ2lmeVJlbWl4KGRhdGEpLCB7XG4gICAgICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICB9KTtcbn07XG5leHBvcnRzLnR5cGVkanNvbiA9IHR5cGVkanNvbjtcbmNvbnN0IHR5cGVkZGVmZXIgPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gICAgLy8gd3JhcCBhbnkgUHJvbWlzZXMgaW4gdGhlIGRhdGEgd2l0aCBuZXcgUHJvbWlzZXMgdGhhdCB3aWxsIHNlcmlhbGl6ZSB0aGVcbiAgICAvLyByZXNvbHZlZCBkYXRhIGFuZCBhZGQgdGhlIG1ldGEgdG8gdGhlIHJlc3BvbnNlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlLnRoZW4ocmVzb2x2ZWREYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGEgfSA9IF90eXBlZGpzb24uc2VyaWFsaXplKHJlc29sdmVkRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZERhdGFbJyQkbWV0YSddID0gbWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkRGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBtZXRhIH0gPSBfdHlwZWRqc29uLnNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGRhdGFbJyQkbWV0YSddID0gbWV0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gJ251bWJlcicgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcbiAgICByZXR1cm4gKDAsIHNlcnZlcl9ydW50aW1lXzEuZGVmZXIpKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuZXhwb3J0cy50eXBlZGRlZmVyID0gdHlwZWRkZWZlcjtcbmZ1bmN0aW9uIFR5cGVkQXdhaXQocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkocmVhY3RfMS5Bd2FpdCwgeyAuLi5wcm9wcywgY2hpbGRyZW46IGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkRGF0YSA9IGRlc2VyaWFsaXplUmVtaXgoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5UeXBlZEF3YWl0ID0gVHlwZWRBd2FpdDtcbmZ1bmN0aW9uIHVzZVR5cGVkTG9hZGVyRGF0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gKDAsIHJlYWN0XzEudXNlTG9hZGVyRGF0YSkoKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVSZW1peChkYXRhKTtcbn1cbmV4cG9ydHMudXNlVHlwZWRMb2FkZXJEYXRhID0gdXNlVHlwZWRMb2FkZXJEYXRhO1xuZnVuY3Rpb24gdXNlVHlwZWRBY3Rpb25EYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgcmVhY3RfMS51c2VBY3Rpb25EYXRhKSgpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVJlbWl4KGRhdGEpO1xufVxuZXhwb3J0cy51c2VUeXBlZEFjdGlvbkRhdGEgPSB1c2VUeXBlZEFjdGlvbkRhdGE7XG5mdW5jdGlvbiB1c2VUeXBlZEZldGNoZXIob3B0cykge1xuICAgIGNvbnN0IGZldGNoZXIgPSAoMCwgcmVhY3RfMS51c2VGZXRjaGVyKShvcHRzKTtcbiAgICBpZiAoZmV0Y2hlci5kYXRhKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBkZXNlcmlhbGl6ZVJlbWl4KGZldGNoZXIuZGF0YSk7XG4gICAgICAgIGZldGNoZXIuZGF0YSA9IG5ld0RhdGEgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hlcjtcbn1cbmV4cG9ydHMudXNlVHlwZWRGZXRjaGVyID0gdXNlVHlwZWRGZXRjaGVyO1xuZnVuY3Rpb24gdXNlVHlwZWRSb3V0ZUxvYWRlckRhdGEoaWQpIHtcbiAgICBjb25zdCBtYXRjaCA9ICgwLCByZWFjdF8xLnVzZU1hdGNoZXMpKCkuZmluZChtYXRjaCA9PiBtYXRjaC5pZCA9PT0gaWQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplUmVtaXgobWF0Y2guZGF0YSk7XG59XG5leHBvcnRzLnVzZVR5cGVkUm91dGVMb2FkZXJEYXRhID0gdXNlVHlwZWRSb3V0ZUxvYWRlckRhdGE7XG5mdW5jdGlvbiBzdHJpbmdpZnlSZW1peChkYXRhKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgSlNPTiBzdHJpbmdpZmljYXRpb25cbiAgICBsZXQgeyBqc29uLCBtZXRhIH0gPSBfdHlwZWRqc29uLnNlcmlhbGl6ZShkYXRhKTtcbiAgICBpZiAoanNvbiAmJiBtZXRhKSB7XG4gICAgICAgIGlmIChqc29uLnN0YXJ0c1dpdGgoJ3snKSkge1xuICAgICAgICAgICAganNvbiA9IGAke2pzb24uc3Vic3RyaW5nKDAsIGpzb24ubGVuZ3RoIC0gMSl9LFxcXCIkJG1ldGFcXFwiOiR7SlNPTi5zdHJpbmdpZnkobWV0YSl9fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgICAgIGpzb24gPSBge1wiJCRvYmpcIjoke2pzb259LFwiJCRtZXRhXCI6JHtKU09OLnN0cmluZ2lmeShtZXRhKX19YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5UmVtaXggPSBzdHJpbmdpZnlSZW1peDtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplUmVtaXgoZGF0YSkge1xuICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgaWYgKGRhdGEuJCRvYmopIHtcbiAgICAgICAgLy8gaGFuZGxlIGFycmF5cyB3cmFwcGVkIGluIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gZGF0YS4kJG1ldGFcbiAgICAgICAgICAgID8gX3R5cGVkanNvbi5hcHBseU1ldGEoZGF0YS4kJG9iaiwgZGF0YS4kJG1ldGEpXG4gICAgICAgICAgICA6IGRhdGEuJCRvYmo7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEuJCRtZXRhKSB7XG4gICAgICAgIC8vIGhhbmRsZSBvYmplY3Qgd2l0aCAkJG1ldGEga2V5XG4gICAgICAgIC8vIHJlbW92ZSBiZWZvcmUgYXBwbHlpbmcgbWV0YVxuICAgICAgICBjb25zdCBtZXRhID0gZGF0YS4kJG1ldGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhLiQkbWV0YTtcbiAgICAgICAgcmV0dXJuIF90eXBlZGpzb24uYXBwbHlNZXRhKGRhdGEsIG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVSZW1peCA9IGRlc2VyaWFsaXplUmVtaXg7XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3JlZGlyZWN0XG4gKi9cbmNvbnN0IHJlZGlyZWN0ID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICAgIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnTG9jYXRpb24nLCB1cmwpO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remix-typedjson/dist/remix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/remix-typedjson/dist/typedjson.js":
/*!********************************************************!*\
  !*** ./node_modules/remix-typedjson/dist/typedjson.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.serialize = exports.parse = exports.deserialize = exports.applyMeta = exports.splitKey = exports.registerCustomType = void 0;\nlet customTypeMap = new Map();\nfunction registerCustomType(entry) {\n    customTypeMap.set(entry.type, entry);\n}\nexports.registerCustomType = registerCustomType;\nfunction serialize(data) {\n    if (data === null)\n        return { json: 'null' };\n    if (data === undefined)\n        return { json: undefined };\n    const stack = [];\n    const keys = [''];\n    const meta = new Map();\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    function replacer(key, value) {\n        function unwindStack() {\n            while (stack.length > 0) {\n                const top = stack[stack.length - 1];\n                if (top.iteration < top.count) {\n                    top.iteration++;\n                    return top;\n                }\n                if (top.type === 'object') {\n                    keys.pop();\n                }\n                stack.pop();\n            }\n        }\n        let entry = unwindStack();\n        if (entry) {\n            value = entry.value[key];\n        }\n        // handle dotted keys\n        if (key.includes('.')) {\n            key = `[${key}]`;\n        }\n        let metaKey = `${keys[keys.length - 1]}${key}`;\n        const valueType = typeof value;\n        if (valueType === 'object' && value !== null) {\n            let count = 0;\n            let t = 'undefined';\n            if (value instanceof Date) {\n                t = 'date';\n                value = value.toISOString();\n            }\n            else if (value instanceof Set) {\n                value = Array.from(value);\n                count = value.length;\n                t = 'set';\n            }\n            else if (value instanceof Map) {\n                value = Object.fromEntries(value);\n                count = Object.keys(value).length;\n                t = 'map';\n            }\n            else if (value instanceof Array) {\n                t = 'object';\n                count = value.length;\n            }\n            else if (value instanceof RegExp) {\n                t = 'regexp';\n                value = String(value);\n            }\n            else if (value instanceof Error) {\n                t = 'error';\n                value = { name: value.name, message: value.message, stack: value.stack };\n                // push error value to stack\n                stack.push({ type: 'object', value, count: 3, iteration: 0 });\n            }\n            else {\n                // check for custom types\n                let customType;\n                if (customTypeMapValues.length > 0) {\n                    customType = customTypeMapValues.find(entry => entry.is(value));\n                }\n                if (customType) {\n                    t = customType.type;\n                    value = customType.serialize(value);\n                }\n                else {\n                    count = Object.keys(value).length;\n                    t = 'object';\n                }\n            }\n            if (t !== 'object') {\n                meta.set(metaKey, t);\n            }\n            if (count !== 0) {\n                stack.push({ type: t, value, count, iteration: 0 });\n                if (key && t === 'object') {\n                    keys.push(`${metaKey}.`);\n                }\n                return value;\n            }\n        }\n        // handle non-object types\n        if (valueType === 'bigint') {\n            meta.set(metaKey, 'bigint');\n            return String(value);\n        }\n        if (valueType === 'number') {\n            if (value === Number.POSITIVE_INFINITY) {\n                meta.set(metaKey, 'infinity');\n                return 'Infinity';\n            }\n            if (value === Number.NEGATIVE_INFINITY) {\n                meta.set(metaKey, '-infinity');\n                return '-Infinity';\n            }\n            if (Number.isNaN(value)) {\n                meta.set(metaKey, 'nan');\n                return 'NaN';\n            }\n        }\n        if (typeof value === 'undefined') {\n            meta.set(metaKey, 'undefined');\n            return null;\n        }\n        return value;\n    }\n    const json = JSON.stringify(data, replacer);\n    return {\n        json,\n        meta: meta.size === 0 ? undefined : Object.fromEntries(meta.entries()),\n    };\n}\nexports.serialize = serialize;\nfunction deserialize({ json, meta }) {\n    if (typeof json === 'undefined') {\n        return undefined;\n    }\n    if (!json)\n        return null;\n    const result = JSON.parse(json);\n    if (meta) {\n        applyMeta(result, meta);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\nconst splitKey = (key) => {\n    // key is a dotted path\n    // may contain escaped dots which are keys wrapped in []\n    // example [b.c].d => ['b.c', 'd']\n    const keys = [];\n    const parts = key.split('.');\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i].startsWith('[')) {\n            let k = parts[i].substring(1);\n            let j = i + 1;\n            while (!parts[j].endsWith(']')) {\n                k += `.${parts[j]}`;\n                j++;\n            }\n            k += `.${parts[j].slice(0, -1)}`;\n            keys.push(k);\n            i = j;\n        }\n        else {\n            keys.push(parts[i]);\n        }\n    }\n    return keys;\n};\nexports.splitKey = splitKey;\nfunction applyMeta(data, meta) {\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    for (const key of Object.keys(meta)) {\n        const keys = (0, exports.splitKey)(key);\n        applyConversion(data, keys, meta[key]);\n    }\n    return data;\n    function applyConversion(data, keys, type, depth = 0) {\n        const key = keys[depth];\n        if (depth < keys.length - 1) {\n            applyConversion(data[key], keys, type, depth + 1);\n            return;\n        }\n        const value = data[key];\n        switch (type) {\n            case 'date':\n                data[key] = new Date(value);\n                break;\n            case 'set':\n                data[key] = new Set(value);\n                break;\n            case 'map':\n                data[key] = new Map(Object.entries(value));\n                break;\n            case 'regexp':\n                const match = /^\\/(.*)\\/([dgimsuy]*)$/.exec(value);\n                if (match) {\n                    data[key] = new RegExp(match[1], match[2]);\n                }\n                else {\n                    throw new Error(`Invalid regexp: ${value}`);\n                }\n                break;\n            case 'bigint':\n                data[key] = BigInt(value);\n                break;\n            case 'undefined':\n                data[key] = undefined;\n                break;\n            case 'infinity':\n                data[key] = Number.POSITIVE_INFINITY;\n                break;\n            case '-infinity':\n                data[key] = Number.NEGATIVE_INFINITY;\n                break;\n            case 'nan':\n                data[key] = NaN;\n                break;\n            case 'error':\n                const err = new Error(value.message);\n                err.name = value.name;\n                err.stack = value.stack;\n                data[key] = err;\n                break;\n            default:\n                // custom types\n                let customType = customTypeMap.get(type);\n                if (customType) {\n                    data[key] = customType.deserialize(value);\n                }\n        }\n    }\n}\nexports.applyMeta = applyMeta;\nfunction stringify(data, replacer, space) {\n    if (replacer || space) {\n        const { json, meta } = serialize(data);\n        const jsonObj = deserialize({ json });\n        return JSON.stringify({\n            json: jsonObj,\n            meta,\n        }, replacer, space);\n    }\n    return JSON.stringify(serialize(data));\n}\nexports.stringify = stringify;\nfunction parse(json) {\n    const result = JSON.parse(json);\n    return result ? deserialize(result) : null;\n}\nexports.parse = parse;\nconst typedjson = {\n    serialize,\n    stringify,\n    deserialize,\n    parse,\n    applyMeta,\n};\nexports[\"default\"] = typedjson;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtaXgtdHlwZWRqc29uL2Rpc3QvdHlwZWRqc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRywwQkFBMEI7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBLHlCQUF5QixzQkFBc0IsRUFBRSxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsNkJBQTZCLCtDQUErQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2hhZ2FyLmlzaGF5L2ZhbmZpYy9ub2RlX21vZHVsZXMvcmVtaXgtdHlwZWRqc29uL2Rpc3QvdHlwZWRqc29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLmRlc2VyaWFsaXplID0gZXhwb3J0cy5hcHBseU1ldGEgPSBleHBvcnRzLnNwbGl0S2V5ID0gZXhwb3J0cy5yZWdpc3RlckN1c3RvbVR5cGUgPSB2b2lkIDA7XG5sZXQgY3VzdG9tVHlwZU1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ3VzdG9tVHlwZShlbnRyeSkge1xuICAgIGN1c3RvbVR5cGVNYXAuc2V0KGVudHJ5LnR5cGUsIGVudHJ5KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDdXN0b21UeXBlID0gcmVnaXN0ZXJDdXN0b21UeXBlO1xuZnVuY3Rpb24gc2VyaWFsaXplKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHsganNvbjogJ251bGwnIH07XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHsganNvbjogdW5kZWZpbmVkIH07XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gWycnXTtcbiAgICBjb25zdCBtZXRhID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGN1c3RvbVR5cGVNYXBWYWx1ZXMgPSBBcnJheS5mcm9tKGN1c3RvbVR5cGVNYXAudmFsdWVzKCkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgZnVuY3Rpb24gdW53aW5kU3RhY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0b3AuaXRlcmF0aW9uIDwgdG9wLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5pdGVyYXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZW50cnkgPSB1bndpbmRTdGFjaygpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZW50cnkudmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgZG90dGVkIGtleXNcbiAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBrZXkgPSBgWyR7a2V5fV1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRhS2V5ID0gYCR7a2V5c1trZXlzLmxlbmd0aCAtIDFdfSR7a2V5fWA7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgdCA9ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHQgPSAnZGF0ZSc7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEFycmF5LmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHQgPSAnc2V0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBPYmplY3QuZnJvbUVudHJpZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0ID0gJ21hcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdCA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICB0ID0gJ3JlZ2V4cCc7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHQgPSAnZXJyb3InO1xuICAgICAgICAgICAgICAgIHZhbHVlID0geyBuYW1lOiB2YWx1ZS5uYW1lLCBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBzdGFjazogdmFsdWUuc3RhY2sgfTtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGVycm9yIHZhbHVlIHRvIHN0YWNrXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IHR5cGU6ICdvYmplY3QnLCB2YWx1ZSwgY291bnQ6IDMsIGl0ZXJhdGlvbjogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gdHlwZXNcbiAgICAgICAgICAgICAgICBsZXQgY3VzdG9tVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tVHlwZU1hcFZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVR5cGUgPSBjdXN0b21UeXBlTWFwVmFsdWVzLmZpbmQoZW50cnkgPT4gZW50cnkuaXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IGN1c3RvbVR5cGUudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjdXN0b21UeXBlLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAnb2JqZWN0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZXRhLnNldChtZXRhS2V5LCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyB0eXBlOiB0LCB2YWx1ZSwgY291bnQsIGl0ZXJhdGlvbjogMCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChgJHttZXRhS2V5fS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBub24tb2JqZWN0IHR5cGVzXG4gICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBtZXRhLnNldChtZXRhS2V5LCAnYmlnaW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICBtZXRhLnNldChtZXRhS2V5LCAnaW5maW5pdHknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgbWV0YS5zZXQobWV0YUtleSwgJy1pbmZpbml0eScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbWV0YS5zZXQobWV0YUtleSwgJ25hbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWV0YS5zZXQobWV0YUtleSwgJ3VuZGVmaW5lZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgcmVwbGFjZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb24sXG4gICAgICAgIG1ldGE6IG1ldGEuc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IE9iamVjdC5mcm9tRW50cmllcyhtZXRhLmVudHJpZXMoKSksXG4gICAgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZnVuY3Rpb24gZGVzZXJpYWxpemUoeyBqc29uLCBtZXRhIH0pIHtcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghanNvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBpZiAobWV0YSkge1xuICAgICAgICBhcHBseU1ldGEocmVzdWx0LCBtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbmNvbnN0IHNwbGl0S2V5ID0gKGtleSkgPT4ge1xuICAgIC8vIGtleSBpcyBhIGRvdHRlZCBwYXRoXG4gICAgLy8gbWF5IGNvbnRhaW4gZXNjYXBlZCBkb3RzIHdoaWNoIGFyZSBrZXlzIHdyYXBwZWQgaW4gW11cbiAgICAvLyBleGFtcGxlIFtiLmNdLmQgPT4gWydiLmMnLCAnZCddXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGFydHNbaV0uc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgICAgICBsZXQgayA9IHBhcnRzW2ldLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGxldCBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoIXBhcnRzW2pdLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICBrICs9IGAuJHtwYXJ0c1tqXX1gO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gYC4ke3BhcnRzW2pdLnNsaWNlKDAsIC0xKX1gO1xuICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFydHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcbmV4cG9ydHMuc3BsaXRLZXkgPSBzcGxpdEtleTtcbmZ1bmN0aW9uIGFwcGx5TWV0YShkYXRhLCBtZXRhKSB7XG4gICAgY29uc3QgY3VzdG9tVHlwZU1hcFZhbHVlcyA9IEFycmF5LmZyb20oY3VzdG9tVHlwZU1hcC52YWx1ZXMoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YSkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9ICgwLCBleHBvcnRzLnNwbGl0S2V5KShrZXkpO1xuICAgICAgICBhcHBseUNvbnZlcnNpb24oZGF0YSwga2V5cywgbWV0YVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gICAgZnVuY3Rpb24gYXBwbHlDb252ZXJzaW9uKGRhdGEsIGtleXMsIHR5cGUsIGRlcHRoID0gMCkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2RlcHRoXTtcbiAgICAgICAgaWYgKGRlcHRoIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBhcHBseUNvbnZlcnNpb24oZGF0YVtrZXldLCBrZXlzLCB0eXBlLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAvXlxcLyguKilcXC8oW2RnaW1zdXldKikkLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gbmV3IFJlZ0V4cChtYXRjaFsxXSwgbWF0Y2hbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZ2V4cDogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luZmluaXR5JzpcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctaW5maW5pdHknOlxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25hbic6XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gTmFOO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcih2YWx1ZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnIubmFtZSA9IHZhbHVlLm5hbWU7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gdmFsdWUuc3RhY2s7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gZXJyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gdHlwZXNcbiAgICAgICAgICAgICAgICBsZXQgY3VzdG9tVHlwZSA9IGN1c3RvbVR5cGVNYXAuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGN1c3RvbVR5cGUuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXBwbHlNZXRhID0gYXBwbHlNZXRhO1xuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIGlmIChyZXBsYWNlciB8fCBzcGFjZSkge1xuICAgICAgICBjb25zdCB7IGpzb24sIG1ldGEgfSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgY29uc3QganNvbk9iaiA9IGRlc2VyaWFsaXplKHsganNvbiB9KTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGpzb246IGpzb25PYmosXG4gICAgICAgICAgICBtZXRhLFxuICAgICAgICB9LCByZXBsYWNlciwgc3BhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGRhdGEpKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gcGFyc2UoanNvbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgcmV0dXJuIHJlc3VsdCA/IGRlc2VyaWFsaXplKHJlc3VsdCkgOiBudWxsO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuY29uc3QgdHlwZWRqc29uID0ge1xuICAgIHNlcmlhbGl6ZSxcbiAgICBzdHJpbmdpZnksXG4gICAgZGVzZXJpYWxpemUsXG4gICAgcGFyc2UsXG4gICAgYXBwbHlNZXRhLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVkanNvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remix-typedjson/dist/typedjson.js\n");

/***/ })

};
;